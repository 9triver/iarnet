---
# 批量安装 Docker 引擎的 Ansible Playbook
# 适用于 Ubuntu 22.04

- name: 安装 Docker 引擎
  hosts: docker
  become: yes
  gather_facts: yes
  
  vars:
    docker_compose_version: "2.24.0"
    
  tasks:
    - name: 检查 Docker 是否已安装
      command: docker --version
      register: docker_version_check
      changed_when: false
      failed_when: false
      
    - name: 显示 Docker 安装状态
      debug:
        msg: "Docker 已安装: {{ docker_version_check.stdout | default('未安装') }}"
        
    - name: 跳过已安装 Docker 的节点
      meta: end_host
      when: docker_version_check.rc == 0
      
    - name: 更新 apt 包索引
      apt:
        update_cache: yes
        cache_valid_time: 3600
        
    - name: 安装必要的依赖包
      apt:
        name:
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
        state: present
        
    - name: 删除旧的 Docker GPG 密钥（如果存在）
      file:
        path: /etc/apt/keyrings/docker.gpg
        state: absent
      ignore_errors: yes
      
    - name: 删除旧的 Docker 仓库配置（如果存在）
      file:
        path: /etc/apt/sources.list.d/docker.list
        state: absent
      ignore_errors: yes
      
    - name: 创建 keyrings 目录
      file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'
        
    - name: 添加 Docker 官方 GPG 密钥（方法1：管道方式）
      shell: |
        curl --retry 3 --retry-delay 5 -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        chmod a+r /etc/apt/keyrings/docker.gpg
      register: gpg_key_added
      retries: 3
      delay: 5
      until: gpg_key_added.rc == 0
      ignore_errors: yes
      
    - name: 验证 GPG 密钥文件（第一次）
      stat:
        path: /etc/apt/keyrings/docker.gpg
      register: gpg_key_file
      
    - name: 如果方法1失败，使用方法2（分步下载）
      shell: |
        curl --retry 5 --retry-delay 5 -fsSL https://download.docker.com/linux/ubuntu/gpg -o /tmp/docker.gpg.asc
        gpg --dearmor < /tmp/docker.gpg.asc > /etc/apt/keyrings/docker.gpg
        chmod a+r /etc/apt/keyrings/docker.gpg
        rm -f /tmp/docker.gpg.asc
      register: gpg_key_retry
      when: gpg_key_added.rc != 0 or gpg_key_file.stat.size < 2000
      retries: 3
      delay: 10
      until: gpg_key_retry.rc == 0
      ignore_errors: yes
      
    - name: 验证 GPG 密钥文件（最终）
      stat:
        path: /etc/apt/keyrings/docker.gpg
      register: gpg_key_file_final
      
    - name: 检查 GPG 密钥文件是否有效
      fail:
        msg: "GPG 密钥文件无效（大小为 {{ gpg_key_file_final.stat.size }} bytes，应该大于 2000 bytes）。请检查网络连接。"
      when: gpg_key_file_final.stat.size < 2000
      
    - name: 显示 GPG 密钥信息
      debug:
        msg: "GPG 密钥文件大小: {{ gpg_key_file_final.stat.size }} bytes"
        
    - name: 添加 Docker 仓库
      shell: |
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
      register: repo_added
      
    - name: 配置 apt 重试和超时设置
      lineinfile:
        path: /etc/apt/apt.conf.d/99-retry
        line: "{{ item }}"
        create: yes
        mode: '0644'
      loop:
        - 'Acquire::Retries "10";'
        - 'Acquire::http::Timeout "120";'
        - 'Acquire::https::Timeout "120";'
        - 'Acquire::ftp::Timeout "120";'
        - 'Acquire::Queue-Mode "access";'
        
    - name: 停止 unattended-upgrades 服务（避免与安装冲突）
      systemd:
        name: unattended-upgrades
        state: stopped
      ignore_errors: yes
      register: stop_unattended_result
      
    - name: 等待 apt-get 锁文件释放
      shell: |
        # 等待最多 60 秒，每 2 秒检查一次
        timeout=60
        interval=2
        elapsed=0
        
        while [ $elapsed -lt $timeout ]; do
          # 检查是否有其他 apt-get/dpkg 进程正在运行（排除当前 shell 和 grep 进程）
          # 使用 [a]pt-get 这样的模式避免 grep 匹配到自己
          running_pids=$(ps aux | grep -E '[a]pt-get|[d]pkg|[u]nattended-upgrade' | grep -v "grep" | awk '{print $2}' | tr '\n' ' ')
          
          # 检查锁文件
          has_lock=false
          [ -f /var/lib/dpkg/lock-frontend ] && has_lock=true
          [ -f /var/lib/dpkg/lock ] && has_lock=true
          [ -f /var/cache/apt/archives/lock ] && has_lock=true
          
          # 如果既没有进程也没有锁文件，可以继续
          if [ -z "$running_pids" ] && [ "$has_lock" = "false" ]; then
            echo "apt 锁已释放，可以继续安装 (总等待时间: ${elapsed}秒)"
            exit 0
          fi
          
          # 如果有进程或锁文件，等待
          if [ -n "$running_pids" ]; then
            echo "[${elapsed}s] 检测到 apt 进程 (PID: $running_pids)，等待..."
          elif [ "$has_lock" = "true" ]; then
            # 检查锁文件是否真的被占用（通过 lsof）
            lock_holder=$(lsof /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/cache/apt/archives/lock 2>/dev/null | grep -v COMMAND | awk '{print $2}' | sort -u | tr '\n' ' ')
            if [ -n "$lock_holder" ]; then
              echo "[${elapsed}s] 锁文件被进程占用 (PID: $lock_holder)，等待..."
            else
              echo "[${elapsed}s] 锁文件存在但无进程占用，可能是残留文件，继续..."
              exit 0
            fi
          fi
          
          sleep $interval
          elapsed=$((elapsed + interval))
        done
        
        echo "等待超时（${timeout}秒），但继续尝试安装"
        exit 0
      register: wait_lock_result
      changed_when: false
      
    - name: 显示等待锁的结果
      debug:
        msg: "{{ wait_lock_result.stdout_lines }}"
        
    - name: 更新 apt 包索引（添加仓库后）
      apt:
        update_cache: yes
        force_apt_get: yes
      register: apt_update_result
      retries: 5
      delay: 15
      until: apt_update_result is succeeded
      ignore_errors: yes
      
    - name: 如果更新失败且是锁问题，等待后重试
      shell: |
        # 再次等待锁释放
        timeout=180
        interval=5
        elapsed=0
        
        while [ $elapsed -lt $timeout ]; do
          running_processes=$(pgrep -f "apt-get|dpkg|unattended-upgrade" | grep -v $$ | wc -l)
          if [ "$running_processes" -gt 0 ] || [ -f /var/lib/dpkg/lock-frontend ] || [ -f /var/lib/dpkg/lock ] || [ -f /var/cache/apt/archives/lock ]; then
            sleep $interval
            elapsed=$((elapsed + interval))
          else
            break
          fi
        done
        
        # 执行更新
        export DEBIAN_FRONTEND=noninteractive
        apt-get update
      register: apt_update_retry
      when: apt_update_result is failed and ("lock" in (apt_update_result.msg | default("")) | lower)
      retries: 3
      delay: 30
      until: apt_update_retry.rc == 0
      ignore_errors: yes
      
    - name: 安装 Docker Engine、Docker CLI 和 containerd
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-buildx-plugin
          - docker-compose-plugin
        state: present
        update_cache: yes
        force_apt_get: yes
      register: docker_install_result
      retries: 5
      delay: 25
      until: docker_install_result is succeeded
      ignore_errors: yes
      
    - name: 如果安装失败，使用 apt-get 直接安装（带重试和修复）
      shell: |
        export DEBIAN_FRONTEND=noninteractive
        
        # 等待锁文件的函数
        wait_for_apt_lock() {
          timeout=300
          interval=5
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            if pgrep -f "apt-get|dpkg|unattended-upgrade" > /dev/null; then
              echo "检测到其他 apt 进程，等待 ${interval} 秒..."
              sleep $interval
              elapsed=$((elapsed + interval))
            elif [ -f /var/lib/dpkg/lock-frontend ] || [ -f /var/lib/dpkg/lock ] || [ -f /var/cache/apt/archives/lock ]; then
              echo "检测到 apt 锁文件，等待 ${interval} 秒..."
              sleep $interval
              elapsed=$((elapsed + interval))
            else
              return 0
            fi
          done
          echo "警告: 等待锁超时，但继续尝试"
          return 0
        }
        
        for i in {1..5}; do
          echo "尝试安装 Docker (第 $i 次)..."
          
          # 每次重试前都等待锁释放
          wait_for_apt_lock
          
          if apt-get update && apt-get install -y --fix-missing docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin; then
            echo "安装成功！"
            exit 0
          fi
          
          if [ $i -lt 5 ]; then
            echo "安装失败，等待 30 秒后重试..."
            sleep 30
          fi
        done
        echo "所有重试都失败了"
        exit 1
      register: docker_install_manual
      when: docker_install_result is failed
      retries: 3
      delay: 30
      until: docker_install_manual.rc == 0
      ignore_errors: yes
      
    - name: 检查 Docker 是否成功安装
      command: docker --version
      register: docker_check_after_install
      changed_when: false
      failed_when: false
      
    - name: 如果 Docker 仍未安装，报告错误
      fail:
        msg: |
          Docker 安装失败。请检查：
          1. 网络连接是否正常
          2. Docker 仓库是否可以访问 (https://download.docker.com/linux/ubuntu)
          3. SSL/TLS 证书是否有效
          
          错误信息: {{ docker_install_result.msg | default('未知错误') }}
          手动安装输出: {{ docker_install_manual.stdout | default('无') }}
      when: docker_check_after_install.rc != 0
      
    - name: 启动并启用 Docker 服务
      systemd:
        name: docker
        state: started
        enabled: yes
        
    - name: 将用户添加到 docker 组
      user:
        name: "{{ ansible_user }}"
        groups: docker
        append: yes
        
    - name: 等待 Docker 服务就绪
      wait_for:
        path: /var/run/docker.sock
        state: present
        timeout: 30
      when: ansible_user == 'ubuntu'
        
    - name: 验证 Docker 安装
      command: docker --version
      register: docker_version
      changed_when: false
      
    - name: 验证 Docker 服务状态
      systemd:
        name: docker
      register: docker_status
      
    - name: 测试 Docker 运行
      command: docker ps
      register: docker_ps
      changed_when: false
      failed_when: false
      
    - name: 显示安装结果
      debug:
        msg:
          - "✓ Docker 安装成功"
          - "  版本: {{ docker_version.stdout }}"
          - "  服务状态: {{ docker_status.status.ActiveState }}"
          - "  运行测试: {{ '成功' if docker_ps.rc == 0 else '失败' }}"
